// ============================================================================
// LdifService.cs - LDIF File Generation and Import Service
// Environment Builder - Modern test environment creation tool
// Evolved from TreeBuilder 3.4 by Robert Foster
// ============================================================================

using System.IO;
using System.Text;
using EnvironmentBuilderApp.Models;
using Serilog;

namespace EnvironmentBuilderApp.Services;

/// <summary>
/// Service for generating and processing LDIF (LDAP Data Interchange Format) files.
/// LDIF is a standard format for representing LDAP directory data.
/// </summary>
public class LdifService
{
    private readonly ILogger _logger;
    
    // ----------------------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------------------
    
    public LdifService(ILogger logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }
    
    // ----------------------------------------------------------------------------
    // LDIF Generation Methods
    // ----------------------------------------------------------------------------
    
    /// <summary>
    /// Generates a complete LDIF file from an environment configuration
    /// </summary>
    public string GenerateLdif(EnvironmentConfiguration config)
    {
        var sb = new StringBuilder();
        
        // Add LDIF header
        AppendHeader(sb, config);
        
        // Generate tree structure entries
        if (config.TreeConfig.CreateTreeStructure)
        {
            _logger.Information("Generating LDIF for tree structure");
            GenerateTreeEntries(sb, config.TreeConfig.RootNodes, "");
        }
        
        // Generate user entries
        foreach (var userConfig in config.UserConfigs.Where(u => u.IsEnabled))
        {
            _logger.Information("Generating LDIF for user set: {SetName}", userConfig.SetName);
            GenerateUserEntries(sb, userConfig, config.DeleteMode);
        }
        
        _logger.Information("LDIF generation complete");
        return sb.ToString();
    }
    
    /// <summary>
    /// Writes LDIF content to a file
    /// </summary>
    public async Task SaveToFileAsync(string ldifContent, string filePath)
    {
        try
        {
            // Ensure directory exists
            var directory = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            await File.WriteAllTextAsync(filePath, ldifContent, Encoding.UTF8);
            _logger.Information("LDIF file saved to: {FilePath}", filePath);
        }
        catch (Exception ex)
        {
            _logger.Error(ex, "Failed to save LDIF file: {FilePath}", filePath);
            throw;
        }
    }
    
    // ----------------------------------------------------------------------------
    // Private Generation Methods
    // ----------------------------------------------------------------------------
    
    /// <summary>
    /// Appends the LDIF file header
    /// </summary>
    private void AppendHeader(StringBuilder sb, EnvironmentConfiguration config)
    {
        sb.AppendLine("# ============================================================================");
        sb.AppendLine("# LDIF File generated by Environment Builder");
        sb.AppendLine($"# Configuration: {config.Name}");
        sb.AppendLine($"# Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("# Evolved from TreeBuilder 3.4 by Robert Foster");
        sb.AppendLine("# ============================================================================");
        sb.AppendLine();
        sb.AppendLine("version: 1");
        sb.AppendLine();
    }
    
    /// <summary>
    /// Recursively generates LDIF entries for tree nodes
    /// </summary>
    private void GenerateTreeEntries(StringBuilder sb, List<TreeNode> nodes, string parentDn)
    {
        foreach (var node in nodes)
        {
            // Build the DN for this node
            var rdn = node.GetRDN();
            var dn = string.IsNullOrEmpty(parentDn) ? rdn : $"{rdn},{parentDn}";
            
            // Add entry for this node
            sb.AppendLine($"# Container: {node.Name}");
            sb.AppendLine($"dn: {dn}");
            sb.AppendLine("changetype: add");
            
            // Add object classes based on node type
            foreach (var objectClass in GetObjectClassesForNodeType(node.NodeType))
            {
                sb.AppendLine($"objectClass: {objectClass}");
            }
            
            // Add the naming attribute
            sb.AppendLine($"{node.GetAttributeName()}: {node.Name}");
            
            // Add description if present
            if (!string.IsNullOrEmpty(node.Description))
            {
                sb.AppendLine($"description: {node.Description}");
            }
            
            sb.AppendLine();
            
            // Process child nodes recursively
            if (node.Children.Count > 0)
            {
                GenerateTreeEntries(sb, node.Children, dn);
            }
        }
    }
    
    /// <summary>
    /// Generates LDIF entries for a user configuration
    /// </summary>
    private void GenerateUserEntries(StringBuilder sb, UserConfiguration config, bool deleteMode)
    {
        sb.AppendLine($"# User Set: {config.SetName}");
        sb.AppendLine($"# Users: {config.StartNumber} to {config.EndNumber}");
        sb.AppendLine();
        
        for (int i = config.StartNumber; i <= config.EndNumber; i++)
        {
            var username = config.GenerateUsername(i);
            var dn = $"cn={username},{config.UserContext}";
            var email = config.GenerateEmail(username);
            var password = config.GetPassword(username);
            
            sb.AppendLine($"# User: {username}");
            sb.AppendLine($"dn: {dn}");
            
            if (deleteMode)
            {
                // Generate delete entry
                sb.AppendLine("changetype: delete");
            }
            else
            {
                // Generate add entry
                sb.AppendLine("changetype: add");
                
                // Add object classes
                foreach (var objectClass in config.ObjectClasses)
                {
                    sb.AppendLine($"objectClass: {objectClass}");
                }
                
                // Add user attributes
                sb.AppendLine($"cn: {username}");
                sb.AppendLine($"uid: {username}");
                sb.AppendLine($"sn: {config.Surname}");
                sb.AppendLine($"givenName: {config.GivenName}");
                sb.AppendLine($"mail: {email}");
                sb.AppendLine($"userPassword: {password}");
                
                // Add optional attributes
                if (!string.IsNullOrEmpty(config.Title))
                    sb.AppendLine($"title: {config.Title}");
                if (!string.IsNullOrEmpty(config.TelephoneNumber))
                    sb.AppendLine($"telephoneNumber: {config.TelephoneNumber}");
                if (!string.IsNullOrEmpty(config.Location))
                    sb.AppendLine($"l: {config.Location}");
                if (!string.IsNullOrEmpty(config.Department))
                    sb.AppendLine($"departmentNumber: {config.Department}");
            }
            
            sb.AppendLine();
        }
    }
    
    /// <summary>
    /// Gets object classes for a tree node type
    /// </summary>
    private IEnumerable<string> GetObjectClassesForNodeType(TreeNodeType nodeType)
    {
        return nodeType switch
        {
            TreeNodeType.Organization => new[] { "organization", "top" },
            TreeNodeType.OrganizationalUnit => new[] { "organizationalUnit", "top" },
            TreeNodeType.Container => new[] { "container", "top" },
            TreeNodeType.Country => new[] { "country", "top" },
            TreeNodeType.Domain => new[] { "domain", "top" },
            _ => new[] { "organizationalUnit", "top" }
        };
    }
    
    // ----------------------------------------------------------------------------
    // LDIF Parsing Methods
    // ----------------------------------------------------------------------------
    
    /// <summary>
    /// Parses an LDIF file and returns the entries
    /// </summary>
    public async Task<List<LdifEntry>> ParseLdifFileAsync(string filePath)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException($"LDIF file not found: {filePath}");
            
        var content = await File.ReadAllTextAsync(filePath);
        return ParseLdifContent(content);
    }
    
    /// <summary>
    /// Parses LDIF content into entry objects
    /// </summary>
    public List<LdifEntry> ParseLdifContent(string content)
    {
        var entries = new List<LdifEntry>();
        var lines = content.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        
        LdifEntry? currentEntry = null;
        
        foreach (var line in lines)
        {
            // Skip comments and empty lines between entries
            if (line.StartsWith("#") || string.IsNullOrWhiteSpace(line))
            {
                if (currentEntry != null && !string.IsNullOrEmpty(currentEntry.Dn))
                {
                    entries.Add(currentEntry);
                    currentEntry = null;
                }
                continue;
            }
            
            // Parse attribute: value
            var colonIndex = line.IndexOf(':');
            if (colonIndex > 0)
            {
                var attribute = line.Substring(0, colonIndex).ToLower();
                var value = line.Substring(colonIndex + 1).TrimStart();
                
                if (attribute == "dn")
                {
                    currentEntry = new LdifEntry { Dn = value };
                }
                else if (currentEntry != null)
                {
                    if (attribute == "changetype")
                        currentEntry.ChangeType = value;
                    else
                        currentEntry.Attributes.Add((attribute, value));
                }
            }
        }
        
        // Add last entry if present
        if (currentEntry != null && !string.IsNullOrEmpty(currentEntry.Dn))
        {
            entries.Add(currentEntry);
        }
        
        _logger.Information("Parsed {Count} entries from LDIF content", entries.Count);
        return entries;
    }
}

/// <summary>
/// Represents a single LDIF entry
/// </summary>
public class LdifEntry
{
    public string Dn { get; set; } = string.Empty;
    public string ChangeType { get; set; } = "add";
    public List<(string Attribute, string Value)> Attributes { get; set; } = new();
}

